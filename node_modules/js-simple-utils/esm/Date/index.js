import locale from './local.js';
import { DATE_STRING, DATE_STRING_FORMAT } from '../RegExp/index.js';
import '../RegExp/password.js';
import '../RegExp/phone.js';

/**
 * @module sDate
 * @since 0.0.2
 * @description sDate模块, 提供正则表达式
 * @example
 * // first import sDate
 * import { sDate } from 'js-simple-utils'
 * // then use sDate
 * sDate.format(new Date(), 'YYYY-MM-DD')
 * sDate.format(new Date(), 'YYYY-MM-DD HH:mm:ss')
 * sDate.format(new Date())
 */
const INVALID_DATE_STRING = 'Invalid Date';
const FORMAT_DEFAULT = 'YYYY-MM-DD HH:mm:ss';
/**
 * @private
 * @param date
 * @returns {string}
 */
const padZoneStr = (date) => {
    const negMinutes = Math.round(date.getTimezoneOffset() / 15) * 15;
    const minutes = Math.abs(negMinutes);
    const hourOffset = Math.floor(minutes / 60);
    const minuteOffset = minutes % 60;
    return `${negMinutes <= 0 ? '+' : '-'}${padStart(hourOffset, 2, '0')}:${padStart(minuteOffset, 2, '0')}`;
};
/**
 * 日期解析
 * @static
 * @param date
 * @param utc
 * @returns {Date}
 */
const parseDate = (date, utc) => {
    if (undefined === date || date === null || date === 'undefined' || date === 'null')
        return new Date(); // today
    if (date instanceof Date)
        return new Date(date);
    if (typeof date === 'string' && !/Z$/i.test(date)) {
        const d = date.match(DATE_STRING);
        if (d) {
            const m = Number(d[2]) - 1 || 0;
            const ms = Number(`${d[7] || '0'}`.substring(0, 3));
            if (utc) {
                return new Date(Date.UTC(Number(d[1]), m, Number(d[3] || 1), Number(d[4] || 0), Number(d[5] || 0), Number(d[6] || 0), ms));
            }
            return new Date(Number(d[1]), m, Number(d[3] || 1), Number(d[4] || 0), Number(d[5] || 0), Number(d[6] || 0), ms);
        }
    }
    return new Date(date);
};
/**
 * 补全日期
 * @private
 * @param string
 * @param length
 * @param pad
 * @returns {string}
 */
const padStart = (string, length, pad) => {
    const s = String(string);
    if (!s || s.length >= length)
        return s;
    return `${Array(length + 1 - s.length).join(pad)}${string}`;
};
/**
 * 日期格式化
 * @static
 * @since 0.0.2
 * @param {?string} date 待格式化的日期
 * @param {?string} template 格式化模版
 * @param {?string} loc 语言
 * @returns {string} 格式化后的日期
 * @example
 * sDate.format(new Date(), 'YYYY-MM-DD') // => '2020-01-01'
 */
const format = (date, template = FORMAT_DEFAULT, loc = 'zh') => {
    const d = parseDate(date);
    if (d.toString() === INVALID_DATE_STRING)
        return INVALID_DATE_STRING;
    const zoneStr = padZoneStr(d);
    const $y = d.getFullYear();
    const $M = d.getMonth();
    const $D = d.getDate();
    const $W = d.getDay();
    const $H = d.getHours();
    const $m = d.getMinutes();
    const $s = d.getSeconds();
    const $ms = d.getMilliseconds();
    const { weekdays, weekdaysShort, months, monthsShort, meridiem, weekdaysMin } = locale[loc];
    const getShort = (arr, index, full, length) => (arr && arr[index]) || full[index].substr(0, length);
    const get$H = (num) => padStart($H % 12 || 12, num, '0');
    const meridiemFunc = meridiem ||
        ((hour, minute, isLowercase) => {
            const m = hour < 12 ? 'AM' : 'PM';
            return isLowercase ? m.toLowerCase() : m;
        });
    const matches = {
        YY: String($y).slice(-2),
        YYYY: $y,
        M: $M + 1,
        MM: padStart($M + 1, 2, '0'),
        MMM: getShort(monthsShort, $M, months, 3),
        MMMM: getShort(months, $M),
        D: $D,
        DD: padStart($D, 2, '0'),
        d: String($W),
        dd: getShort(weekdaysMin, $W, weekdays, 2),
        ddd: getShort(weekdaysShort, $W, weekdays, 3),
        dddd: weekdays[$W],
        H: String($H),
        HH: padStart($H, 2, '0'),
        h: get$H(1),
        hh: get$H(2),
        a: meridiemFunc($H, $m, true),
        A: meridiemFunc($H, $m, false),
        m: String($m),
        mm: padStart($m, 2, '0'),
        s: String($s),
        ss: padStart($s, 2, '0'),
        SSS: padStart($ms, 3, '0'),
        Z: zoneStr, // 'ZZ' logic below
    };
    return template.replace(DATE_STRING_FORMAT, (match, $1) => $1 || matches[match] || zoneStr.replace(':', ''));
};
var index = { parseDate, format };

export { index as default, format, parseDate };
